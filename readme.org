#+title: init.org
#+startup: overview

* Bootstrap
** 設定ファイルのヘッダー
*** early-init.el
#+begin_src emacs-lisp :tangle early-init.el
;;; early-init.el
;;; -*- lexical-binding: t -*-
#+end_src
*** init.el
#+begin_src emacs-lisp :lexical no
;;; init.el
;;; -*- lexical-binding: t -*-
#+end_src
** early-init.el
*** 起動時間短縮のための設定
#+begin_src emacs-lisp :tangle early-init.el
(defvar default-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(setq gc-cons-percentage 1.0)
(setq gc-cons-threshold most-positive-fixnum)

(defun e:emacs-startup-config ()
  (setq file-name-handler-alist default-file-name-handler-alist)
  (setq gc-cons-percentage 0.1)
  (setq gc-cons-threshold 10485760))
(add-hook 'emacs-startup-hook #'e:emacs-startup-config)
#+end_src
*** 不要なUI要素を非表示
#+begin_src emacs-lisp :tangle early-init.el
(menu-bar-mode   -1)
(scroll-bar-mode -1)
(tool-bar-mode   -1)
(tooltip-mode    -1)
#+end_src
*** `package.el' を使用しない
#+begin_src emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src
*** 未ロードならロードする
#+begin_src emacs-lisp
(unless early-init-file
  (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src
** 起動時間の計測
#+begin_src emacs-lisp :lexical no
(when init-file-debug
  (require 'profiler)
  (profiler-start 'cpu))
#+end_src
** 各種ディレクトリ
#+begin_src emacs-lisp
(setq user-emacs-directory (file-name-directory (or load-file-name buffer-file-name)))
(setq no-littering-etc-directory (expand-file-name "etc/" user-emacs-directory))
(setq no-littering-var-directory (expand-file-name "var/" user-emacs-directory))
(add-to-list 'load-path (expand-file-name "lisp/" user-emacs-directory))
#+end_src
** マクロ定義
*** cl-lib
#+begin_src emacs-lisp
(eval-when-compile (require 'cl-lib))
#+end_src
*** e:default!
#+begin_src emacs-lisp
(defmacro e:default! (variable default)
  `(setq-default ,variable ,default))
#+end_src
*** e:local!
#+begin_src emacs-lisp
(defmacro e:local! (variable value)
  `(setq-local ,variable ,value))
#+end_src
*** e:variable!
#+begin_src emacs-lisp
(defmacro e:variable! (variable value)
  `(set-variable ',variable ,value))
#+end_src
*** e:var!
#+begin_src emacs-lisp
(defmacro e:var! (variable value)
  `(e:variable! ,variable (no-littering-expand-var-file-name ,value)))
#+end_src
*** e:if!
#+begin_src emacs-lisp
(defmacro e:if! (condition &rest body)
  (declare (indent defun))
  (if (eval condition)
      `(progn ,@body)))
#+end_src
*** e:eval!
#+begin_src emacs-lisp
(defmacro e:eval! (&rest body)
  (declare (indent defun))
  `(eval '(progn ,@body)))
#+end_src
*** e:deffered-config!
#+begin_src emacs-lisp
(defvar e:high-priority-config-queue nil)
(defvar e:low-priority-config-queue nil)
(defvar e:deffered-config-loaded nil)
(defmacro e:deffered-config! (package &rest body)
  (declare (indent defun))
  (let* ((priority (or (plist-get body :priority) :low))
         (queue (if (eq priority :high) 'e:high-priority-config-queue 'e:low-priority-config-queue))
         (fn-name (intern (format "e:package-config-%s!" package))))
    `(let ((fn (defun ,fn-name () (leaf ,package ,@body))))
       (if e:deffered-config-loaded
           (funcall fn)
         (setq ,queue (append ,queue (list fn)))))))
#+end_src
*** e:package-config!
#+begin_src emacs-lisp
(defmacro e:package-config! (orders &rest body)
  (declare (indent defun))
  (let ((package (or (car-safe orders) orders)))
    `(progn
       (elpaca ,orders)
       (e:deffered-config! ,package ,@body))))
#+end_src
*** e:mode-key-def
#+begin_src emacs-lisp
(defmacro e:major-mode-key-def (modes key def &rest bindings)
  (declare (indent defun))
  `(e:mode-key-def :major-modes ,modes ,key ,def ,@bindings))
(defmacro e:minor-mode-key-def (modes key def &rest bindings)
  (declare (indent defun))
  `(e:mode-key-def :minor-modes ,modes ,key ,def ,@bindings))
(defmacro e:mode-key-def (mode-key modes key def &rest bindings)
  (declare (indent defun))
  (let* ((modes (if (listp modes) modes (list modes)))
         (mode (or (car-safe modes) modes))
         (command (intern (format "e:%s-command" mode)))
         (map (intern (format "e:%s-command-map" mode)))
         (prefix-bindings nil)
         (general-bindings nil))
    (while key
      (if (stringp def)
          (setq prefix-bindings (append prefix-bindings (list key def)))
        (setq general-bindings (append general-bindings (list key def))))
      (setq key (pop bindings)
            def (pop bindings)))
    `(progn
       (bind-map ,map
         :prefix-cmd ,command
         ,mode-key ,modes
         :keys ("M-<return>" "M-m m")
         :evil-keys ("," "SPC m")
         :evil-states (motion normal visual))
       (general-def ,map ,@general-bindings)
       ,(when prefix-bindings
         `(which-key-add-keymap-based-replacements ,map
            ,@prefix-bindings)))))
#+end_src
*** e:define-minor-mode-switch
#+begin_src emacs-lisp :lexical no
(defmacro e:define-minor-mode-switch (minor-mode)
  `(progn
     (defun ,(intern (format "%s-on" minor-mode)) ()
       ,(format "[generated] Turn on `%s'" minor-mode)
       (interactive)
       (,minor-mode 1))
     (defun ,(intern (format "%s-off" minor-mode)) ()
       ,(format "[generated] Turn off `%s'" minor-mode)
       (interactive)
       (,minor-mode 0))))
#+end_src
** 環境設定
*** Theme
#+begin_src emacs-lisp
(require-theme 'modus-themes)
(load-theme 'modus-vivendi :no-confirm)
#+end_src
*** Font
#+begin_src emacs-lisp
(let ((font "UDEV Gothic NF")
      (size (if (eq system-type 'darwin) 16.0 12.0)))
  (set-frame-font (font-spec :name font :size size) nil t)
  (set-face-attribute 'fixed-pitch       nil :family font)
  (set-face-attribute 'fixed-pitch-serif nil :family font)
  (set-face-attribute 'variable-pitch    nil :family font))
#+end_src
*** Japanese
#+begin_src emacs-lisp
(set-language-environment "Japanese")
#+end_src
*** Encoding
#+begin_src emacs-lisp
(let ((coding-system 'utf-8))
  (prefer-coding-system          coding-system)
  (set-buffer-file-coding-system coding-system))
#+end_src
*** Locale
#+begin_src emacs-lisp
(let ((value "ja_JP.UTF-8"))
  (setenv "LANG" value)
  (setenv "LC_ALL" value))
#+end_src
*** Mac
#+begin_src emacs-lisp
(e:if! (eq system-type 'darwin)
  ;; タイトルバーの見た目を変更
  ;; (--each '((ns-transparent-titlebar . t)
  ;;           (ns-appearance . dark))
  ;;   (assq-delete-all (car it) initial-frame-alist)
  ;;   (assq-delete-all (car it) default-frame-alist)
  ;;   (add-to-list 'initial-frame-alist it)
  ;;   (add-to-list 'default-frame-alist it))
  ;; 特殊キーの設定
  (e:variable! ns-command-modifier 'meta)
  (e:variable! ns-right-command-modifier 'super)
  (e:variable! ns-alternate-modifier 'none)
  ;; ちょっと行間を広げる
  (e:default! line-spacing 2))
#+end_src
** ライブラリ
*** elpaca
**** インストール
#+name: install elpaca
#+begin_src emacs-lisp :tangle no
;; https://github.com/progfolio/elpaca?tab=readme-ov-file#installation
(defvar elpaca-queue-limit 10)
(defvar elpaca-installer-version 0.5)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (call-process "git" nil buffer t "clone"
                                       (plist-get order :repo) repo)))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src
**** byte-compile がエラーになるので暫定対応
#+begin_src emacs-lisp :noweb yes
(e:eval!
  <<install elpaca>>)
#+end_src
*** others
#+begin_src emacs-lisp
(elpaca (komunan-lisp-library :host github :repo "ofnhwx/komunan-lisp-library")
  (require 'komunan-lisp-library))
(elpaca f (require 'f))
(elpaca s (require 's))
(elpaca ht (require 'ht))
(elpaca dash (require 'dash))
(elpaca leaf (require 'leaf))
(elpaca general (require 'general))
(elpaca bind-map (require 'bind-map))
(elpaca hercules (require 'hercules))
(elpaca no-littering (require 'no-littering))
(elpaca-wait)
#+end_src
* Config: Emacs
** startup
#+begin_src emacs-lisp
(e:variable! inhibit-startup-screen t)
(e:variable! initial-scratch-message nil)
#+end_src
** Alias
#+begin_src emacs-lisp
(defalias 'exit 'save-buffers-kill-terminal)
#+end_src
** C Sources
#+begin_src emacs-lisp
(e:default! bidi-display-reordering nil)
(e:default! fill-column 100)
(e:default! truncate-lines t)
(e:variable! create-lockfiles nil)
(e:variable! delete-by-moving-to-trash nil)
(e:variable! enable-recursive-minibuffers t)
(e:variable! frame-resize-pixelwise t)
(e:variable! history-delete-duplicates t)
(e:variable! read-process-output-max 1048576)
(e:variable! ring-bell-function #'ignore)
(e:variable! scroll-conservatively 101)
(e:variable! scroll-margin 5)
(e:variable! scroll-preserve-screen-position t)
(e:variable! shell-file-name
             (or (executable-find "zsh")
                 (executable-find "bash")
                 (executable-find "sh")))
(e:variable! system-time-locale "C")
(e:variable! truncate-partial-width-windows nil)
(e:variable! undo-limit 67108864)         ;; => 64mb.
(e:variable! undo-strong-limit 100663296) ;; => 96mb.
(e:variable! undo-outer-limit 1006632960) ;; => 960mb.
(e:variable! use-dialog-box nil)
(e:variable! use-short-answers t)
(e:variable! window-resize-pixelwise t)
#+end_src
** auto-revert
#+begin_src emacs-lisp
(e:deffered-config! auto-revert
  :config
  (global-auto-revert-mode 1))
#+end_src
** browse-url
#+begin_src emacs-lisp
(e:deffered-config! browse-url
  :commands (browse-url-by-choosen)
  :defun (browse-url-default-browser)
  :defvar (browse-url-generic-program)
  :defer-config
  (e:variable! browse-url-browser-function 'browse-url-by-choosen)
  (defun browse-url-by-choosen (url &optional new-window)
    "選択したブラウザで URL を開く."
    (let ((browsers '(eww-browse-url browse-url-default-browser xwidget-webkit-browse-url)))
      (when browse-url-generic-program
        (add-to-list 'browsers 'browse-url-generic t))
      (funcall (intern (completing-read "Choose Browser: " browsers)) url new-window))))
#+end_src
** comp
#+begin_src emacs-lisp
(e:deffered-config! comp
  :defer-config
  (e:variable! native-comp-async-report-warnings-errors nil))
#+end_src
** compile
#+begin_src emacs-lisp
(e:deffered-config! compile
  :defer-config
  (e:variable! compilation-scroll-output t))
#+end_src
** cus-edit
#+begin_src emacs-lisp
(e:deffered-config! cus-edit
  :defer-config
  (e:var! custom-file "custom.el"))
#+end_src
** dired
*** dired
#+begin_src emacs-lisp
(e:deffered-config! dired
  :defer-config
  (e:variable! dired-auto-revert-buffer t)
  (e:variable! dired-dwim-target t)
  (e:variable! dired-listing-switches "-Ahl")
  (e:variable! dired-omit-files (rx (or (seq bol (? ".") "#")
                                        (seq bol (or "." "..") eol)
                                        (seq bol ".DS_Store" eol))))
  (e:variable! dired-recursive-copies 'always)
  (e:variable! dired-recursive-deletes 'always))
#+end_src
*** treemacs-icons-dired
#+begin_src emacs-lisp
(e:package-config! treemacs-icons-dired
  :hook (dired-mode-hook . treemacs-icons-dired-mode))
#+end_src
*** ls-lisp-extension
#+begin_src emacs-lisp
(e:package-config! (ls-lisp-extension :host github :repo "ofnhwx/ls-lisp-extension")
  :after (dired)
  :config
  (e:variable! ls-lisp-dirs-first t)
  (e:variable! ls-lisp-format-time-list '("%Y-%m-%d %H:%M:%S" "%Y-%m-%d %H:%M:%S"))
  (e:variable! ls-lisp-ignore-case nil)
  (e:variable! ls-lisp-use-insert-directory-program nil)
  (e:variable! ls-lisp-use-localized-time-format t)
  (e:variable! ls-lisp-verbosity '(uid gid))
  (ls-lisp-extension-on))
#+end_src
** display-line-numbers
#+begin_src emacs-lisp
(e:deffered-config! display-line-numbers
  :hook ((find-file-hook . display-line-numbers-mode-on)
         (prog-mode-hook . display-line-numbers-mode-on))
  :defer-config
  (e:default! display-line-numbers-width 4)
  (e:define-minor-mode-switch display-line-numbers-mode))
#+end_src
** emacs-lock
#+begin_src emacs-lisp
(e:deffered-config! emacs-lock
  :config
  (dolist (buffer '("*scratch*" "*Messages*"))
    (with-current-buffer buffer
      (emacs-lock-mode 'kill))))
#+end_src
** epg-config
#+begin_src emacs-lisp :lexical no
(e:deffered-config! epg-config
  :defer-config
  (e:variable! epg-pinentry-mode 'loopback))
#+end_src
** eww
#+begin_src emacs-lisp :lexical no
(e:deffered-config! eww
  :defun (eww-current-url)
  :defer-config
  (general-def eww-mode-map
    "e" 'eww-open-current-url-with-default-browser)
  (e:variable! eww-search-prefix "https://www.google.com/search?q=")
  (defun eww-open-current-url-with-default-browser ()
    (interactive)
    (browse-url-default-browser (eww-current-url))))
#+end_src
** files
#+begin_src emacs-lisp
(e:deffered-config! files
  :defer-config
  (e:variable! auto-save-default nil)
  (e:variable! make-backup-files nil)
  (e:variable! mode-require-final-newline nil)
  (e:variable! require-final-newline nil))
#+end_src
** frame
#+begin_src emacs-lisp
(e:deffered-config! frame
  :defer-config
  (blink-cursor-mode 0))
#+end_src
** google-translate
#+begin_src emacs-lisp :lexical no
(e:package-config! google-translate
  :defer-config
  (e:variable! google-translate-default-source-language "en")
  (e:variable! google-translate-default-target-language "ja"))
#+end_src
** hl-line
#+begin_src emacs-lisp
(e:deffered-config! hl-line
  :hook ((find-file-hook . hl-line-mode-on)
         (prog-mode-hook . hl-line-mode-on))
  :config
  (e:define-minor-mode-switch hl-line-mode))
#+end_src
** indent
#+begin_src emacs-lisp
(e:deffered-config! indent
  :defer-config
  (e:variable! standard-indent 2))
#+end_src
** novice
#+begin_src emacs-lisp
(e:deffered-config! novice
  :defer-config
  (e:variable! disabled-command-function nil))
#+end_src
** recentf
#+begin_src emacs-lisp
(e:deffered-config! recentf
  :advice (:before recentf-save-list ad:recentf-save-list@cleanup)
  :defun (recentf-include-p)
  :defvar (recentf-list)
  :init
  (e:variable! recentf-filename-handlers '(abbreviate-file-name))
  (e:variable! recentf-max-menu-items 20)
  (e:variable! recentf-max-saved-items 3000)
  (defun ad:recentf-save-list@cleanup (&rest _)
    "存在しないファイルを履歴から削除する"
    (setq recentf-list (->> recentf-list
                            (-map 'f-short)
                            (-distinct)
                            (--filter (and (or (file-remote-p it)
                                               (f-exists? it))
                                           (recentf-include-p it))))))
  (recentf-mode 1))
#+end_src
** savehist
#+begin_src emacs-lisp
(e:deffered-config! savehist
  :config
  (savehist-mode 1))
#+end_src
** saveplace
#+begin_src emacs-lisp
(e:deffered-config! save-place
  :config
  (save-place-mode 1))
#+end_src
** simple
#+begin_src emacs-lisp
(e:deffered-config! simple
  :defer-config
  (e:default! indent-tabs-mode nil)
  (e:variable! set-mark-command-repeat-pop t)
  (column-number-mode 1))
#+end_src
** so-long
#+begin_src emacs-lisp
(e:deffered-config! so-long
  :config
  (global-so-long-mode 1))
#+end_src
** tab-bar-mode
#+begin_src emacs-lisp
(e:deffered-config! tab-bar
  :config
  (tab-bar-mode t)
  (defun tab-bar-select-tab-1 () (interactive) (tab-bar-select-tab 1))
  (defun tab-bar-select-tab-2 () (interactive) (tab-bar-select-tab 2))
  (defun tab-bar-select-tab-3 () (interactive) (tab-bar-select-tab 3))
  (defun tab-bar-select-tab-4 () (interactive) (tab-bar-select-tab 4))
  (defun tab-bar-select-tab-5 () (interactive) (tab-bar-select-tab 5))
  (defun tab-bar-select-tab-6 () (interactive) (tab-bar-select-tab 6))
  (defun tab-bar-select-tab-7 () (interactive) (tab-bar-select-tab 7))
  (defun tab-bar-select-tab-8 () (interactive) (tab-bar-select-tab 8))
  (defun tab-bar-select-tab-9 () (interactive) (tab-bar-select-tab 9))
  (defun tab-switch-last ()
    (interactive)
    (if-let* ((tab (car (tab-bar--tabs-recent)))
              (name (alist-get 'name tab)))
        (tab-bar-switch-to-tab name))))
#+end_src
** timer
#+begin_src emacs-lisp
(e:deffered-config! timer
  :advice (:around cancel-timer ad:cancel-timer@workaround)
  :defer-config
  (defun ad:cancel-timer@workaround (fn &rest args)
    (when (timerp (car args))
      (apply fn args))))
#+end_src
** vc-hooks
#+begin_src emacs-lisp
(e:deffered-config! vc-hooks
  :defer-config
  (e:variable! vc-follow-symlinks t))
#+end_src
** whitespace
#+begin_src emacs-lisp
(e:deffered-config! whitespace
  :hook ((find-file-hook . whitespace-mode-on)
         (prog-mode-hook . whitespace-mode-on))
  :defer-config
  (e:variable! whitespace-style '(face
                                  trailing
                                  tabs
                                  tab-mark
                                  spaces
                                  space-mark
                                  newline
                                  newline-mark))
  (e:variable! whitespace-space-regexp "\\(\u3000+\\)")
  (e:variable! whitespace-display-mappings '((space-mark   ?\u3000 [?\u30ed])
                                             (tab-mark     ?\t     [?\t])
                                             (newline-mark ?\n     [?\u0024 ?\n])))
  (let ((color "#595D63"))
    (set-face-attribute 'whitespace-trailing nil :background "#800000")
    (set-face-attribute 'whitespace-tab      nil :foreground color :strike-through t)
    (set-face-attribute 'whitespace-space    nil :foreground color)
    (set-face-attribute 'whitespace-newline  nil :foreground color))
  (e:define-minor-mode-switch whitespace-mode))
#+end_src
** winner
#+begin_src emacs-lisp
(e:deffered-config! winner
  :config
  (winner-mode 1))
#+end_src
** 個人設定
#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (defun e:load-private-config ()
            (let ((private-config (f-expand "config" e:private-directory)))
              (condition-case err
                  (load private-config)
                (display-warning :warning err)))))
#+end_src
* Config: Evil
** evil
#+begin_src emacs-lisp
(e:package-config! evil
  :priority :high
  :defun (evil-get-auxiliary-keymap
          evil-half-cursor
          evil-make-overriding-map
          evil-normalize-keymaps
          evil-set-command-property)
  :init
  (e:variable! evil-cross-lines t)
  (e:variable! evil-disable-insert-state-bindings t)
  (e:variable! evil-move-beyond-eol t)
  (e:variable! evil-move-cursor-back nil)
  (e:variable! evil-shift-width 2)
  (e:variable! evil-want-Y-yank-to-eol t)
  (e:variable! evil-want-keybinding nil)
  ;; cursor colors
  (e:variable! evil-motion-state-cursor  '("plum3" box))
  (e:variable! evil-normal-state-cursor  '("DarkGoldenrod2" box))
  (e:variable! evil-visual-state-cursor  '("gray" (hbar . 2)))
  (e:variable! evil-insert-state-cursor  '("chartreuse3" (bar . 2)))
  (e:variable! evil-replace-state-cursor '("chocolate" (hbar . 2)))
  (e:variable! evil-emacs-state-cursor   '("SkyBlue2" box))
  (e:variable! evil-operator-state-cursor #'evil-half-cursor)
  (evil-mode 1)
  :config
  (general-def 'motion
    "TAB" nil
    "C-\\" 'ignore
    "C-^" nil)
  (general-def 'normal
    "<down>" 'evil-next-visual-line
    "<up>"   'evil-previous-visual-line
    "j" 'evil-next-visual-line
    "k" 'evil-previous-visual-line)
  (general-def 'insert
    "C-z" nil))
#+end_src
** evil-args
#+begin_src emacs-lisp
(e:package-config! evil-args
  :config
  (general-def evil-inner-text-objects-map "a" 'evil-inner-arg)
  (general-def evil-outer-text-objects-map "a" 'evil-outer-arg))
#+end_src
** evil-collection
#+begin_src emacs-lisp
(e:package-config! evil-collection
  :after (evil)
  :config
  (evil-collection-init))
#+end_src
** evil-easymotion
#+begin_src emacs-lisp
(e:package-config! evil-easymotion
  :after (evil)
  :defvar (evilem-map)
  :config
  (evilem-default-keybindings "s")
  (general-def evilem-map
    "s" 'evil-avy-goto-char-timer)
  (general-def 'normal "s" evilem-map)
  (general-def 'visual "x" evilem-map))
#+end_src
** evil-goggles
#+begin_src emacs-lisp
(e:package-config! evil-goggles
  :after (evil)
  :config
  (evil-goggles-mode 1))
#+end_src
** evil-lion
#+begin_src emacs-lisp
(e:package-config! evil-lion
  :after (evil)
  :config
  (evil-lion-mode 1))
#+end_src
** evil-nerd-commenter
#+begin_src emacs-lisp
(e:package-config! evil-nerd-commenter
  :after (evil)
  :require t)
#+end_src
** evil-surround
#+begin_src emacs-lisp
(e:package-config! evil-surround
  :after (evil)
  :config
  (general-def 'visual evil-surround-mode-map "s" 'evil-surround-region)
  (global-evil-surround-mode))
#+end_src
** evil-textobj-tree-sitter
#+begin_src emacs-lisp :lexical no
(e:package-config! evil-textobj-tree-sitter
  :config
  (general-def evil-inner-text-objects-map
    "f" (evil-textobj-tree-sitter-get-textobj "function.inner"))
  (general-def evil-outer-text-objects-map
    "f" (evil-textobj-tree-sitter-get-textobj "function.outer")))
#+end_src
* Config: SKK
** skk
#+begin_src emacs-lisp
(e:package-config! ddskk
  :advice (:around evil-refresh-cursor ad:evil-refresh-cursor@with-skk)
  :defun (skk-latin-mode-on)
  :defvar (skk-mode-hook)
  :hook ((evil-insert-state-entry-hook . e:skk-mode)
         (evil-insert-state-exit-hook . skk-mode-exit))
  :bind (([remap toggle-input-method] . skk-mode)
         ("C-¥" . skk-mode))
  :init
  (e:var! skk-user-directory "ddskk")
  (e:variable! ccc-default-cursor-color "DarkGoldenrod2")
  (e:variable! default-input-method "japanese-skk")
  (e:variable! skk-egg-like-newline t)
  ;; TODO: 辞書の場所を真面目に考える
  ;; (e:variable! skk-large-jisyo (f-expand "dic-mirror/SKK-JISYO.L" e:external-directory))
  (e:variable! skk-share-private-jisyo t)
  (e:variable! skk-show-annotation t)
  (e:variable! skk-sticky-key ";")
  (e:variable! skk-use-jisx0201-input-method t)
  (ccc-setup)
  :defer-config
  (defun e:skk-mode ()
    "skk の有効化で半角英数入力にする"
    (interactive)
    (require 'skk)
    (unless (derived-mode-p 'vterm-mode)
      (if (bound-and-true-p skk-mode)
          (skk-latin-mode-on)
        (let ((skk-mode-hook (-union skk-mode-hook '(skk-latin-mode-on))))
          (skk-mode)))))
  (defun ad:evil-refresh-cursor@with-skk (fn &rest args)
    (unless (and (eq evil-state 'insert)
                 (bound-and-true-p skk-mode))
      (apply fn args))))
#+end_src
** skk-server
#+begin_src emacs-lisp
(e:deffered-config! skk-server
  :after (skk)
  :defun (e:prodigy-yaskkserv2 . prodigy)
  :defvar (skk-server-prog yaskkserv2-dictionary)
  :preface
  (e:variable! skk-server-prog (executable-find "yaskkserv2"))
  (e:variable! yaskkserv2-dictionary (f-expand "~/sync/share/dictionary.yaskkserv2"))
  :if (and (bound-and-true-p skk-server-prog)
           (f-exists? yaskkserv2-dictionary))
  :config
  (e:variable! skk-large-jisyo nil)
  (e:variable! skk-server-inhibit-startup-server t)
  (e:variable! skk-server-host "127.0.0.1")
  (e:variable! skk-server-portnum 1178)
  (defun e:prodigy-yaskkserv2 ()
    (interactive)
    (let ((service "yaskkserv2"))
      (unless (prodigy-find-service service)
        (prodigy-define-service
          :name service
          :command skk-server-prog
          :args `("--no-daemonize" "--google-suggest" ,yaskkserv2-dictionary)
          :tags '(general)
          :stop-signal 'int))
      (prodigy-start-service (prodigy-find-service service))))
  (e:prodigy-yaskkserv2))
#+end_src
** ddskk-posframe
#+begin_src emacs-lisp
(e:package-config! ddskk-posframe
  :after (skk)
  :config
  (ddskk-posframe-mode 1))
#+end_src
* Config: UI & Completions
** cape
*** codeium
#+begin_src emacs-lisp :lexical no
(e:package-config! (codeium :host github :repo "Exafunction/codeium.el")
  :commands (cape-codeium)
  :defer-config
  (defalias 'cape-codeium (cape-capf-interactive #'codeium-completion-at-point)))
#+end_src
*** company-org-block
#+begin_src emacs-lisp
(e:package-config! company-org-block
  :commands (cape-org-block)
  :defer-config
  (e:variable! company-org-block-edit-style 'inline)
  (defalias 'cape-org-block (cape-capf-interactive (cape-company-to-capf #'company-org-block))))
#+end_src
*** company-tabnine
#+begin_src emacs-lisp
(e:package-config! company-tabnine
  :commands (cape-tabnine)
  :defer-config
  (defalias 'cape-tabnine (cape-capf-interactive (cape-company-to-capf #'company-tabnine))))
#+end_src
*** cape
#+begin_src emacs-lisp
(e:package-config! cape
  :defun (e:capf-function)
  :hook ((prog-mode-hook . e:setup-capf/default)
         (org-mode-hook . e:setup-capf/org)
         (lsp-completion-mode-hook . e:setup-capf/lsp))
  :defer-config
  (defun e:capf-function (name &rest capfs)
    (let ((fun (intern (format "e:cape-%s" name)))
          (capfs (-concat capfs '(cape-dabbrev))))
      (defalias fun
        (cape-capf-interactive
         (cape-capf-nonexclusive
          (cape-capf-buster
           (apply #'cape-capf-super capfs)))))
      (list #'cape-file fun)))
  (defun e:setup-capf/default ()
    (interactive)
    (e:local! completion-at-point-functions
              (e:capf-function major-mode (car completion-at-point-functions))))
  (defun e:setup-capf/org ()
    (interactive)
    (e:local! completion-at-point-functions
              (e:capf-function "org" #'cape-elisp-block #'cape-org-block)))
  (defun e:setup-capf/lsp ()
    (interactive)
    (e:local! completion-at-point-functions
              (e:capf-function "lsp" #'lsp-completion-at-point))))
#+end_src
** consult
#+begin_src emacs-lisp
(e:package-config! consult
  :advice (:around consult-line ad:consult-line@with-orderless)
  :commands (consult-faces consult-line-dwim consult-ripgrep-dwim consult-ripgrep-cwd consult-ripgrep-cwd-dwim)
  :defun (consult-ripgrep consult--read)
  :defer-config
  (defun ad:consult-line@with-orderless (fn &rest args)
    (let ((completion-styles '(orderless)))
      (apply fn args)))
  (defun consult-faces ()
    (interactive)
    (consult--read (--map (format "%s" it) (face-list))
                   :prompt "Face: "))
  (defun consult-line-dwim ()
    (interactive)
    (consult-line (thing-at-point 'symbol)))
  (defun consult-ripgrep-dwim ()
    (interactive)
    (consult-ripgrep nil (thing-at-point 'symbol)))
  (defun consult-ripgrep-cwd (&optional initial)
    (interactive)
    (consult-ripgrep default-directory initial))
  (defun consult-ripgrep-cwd-dwim ()
    (interactive)
    (consult-ripgrep default-directory (thing-at-point 'symbol))))
#+end_src
** copilot
#+begin_src emacs-lisp
(e:package-config! (copilot :host github :repo "zerolfx/copilot.el" :files (:defaults "dist"))
  :advice ((:before-until corfu-complete ad:copilot-accept-completion-func)
           (:before-until indent-for-tab-command ad:copilot-accept-completion-func)
           (:before cape-codeium ad:copilot-cancel)
           (:before corfu-quick-complete ad:copilot-cancel))
  :defun (copilot-accept-completion
          copilot-clear-overlay)
  :hook ((prog-mode-hook . copilot-mode)
         (org-mode-hook . copilot-mode))
  :defer-config
  (general-def copilot-mode-map
   "<backtab>" 'copilot-complete
   "C-z" 'copilot-complete)
  (general-def copilot-completion-map
   "<escape>" 'copilot-clear-overlay
   "C-n" 'copilot-next-completion
   "C-p" 'copilot-previous-completion
   "C-z" 'copilot-complete)
  ;; (add-to-list 'copilot-enable-predicates 'ignore)
  (defun ad:copilot-accept-completion-func (&rest _)
    (copilot-accept-completion))
  (defun ad:copilot-cancel (&rest _)
    (copilot-clear-overlay)))
#+end_src
** corfu
#+begin_src emacs-lisp
(e:package-config! corfu
  :defvar (corfu-map)
  :hook ((corfu-mode-hook . corfu-echo-mode)
         (corfu-mode-hook . corfu-popupinfo-mode)
         (minibuffer-setpu-hook . corfu-enable-always-in-minibuffer))
  :init
  (e:variable! corfu-auto t)
  (e:variable! corfu-auto-prefix 1)
  (e:variable! corfu-cycle t)
  (global-corfu-mode)
  :defer-config
  (general-def corfu-map
    "<escape>" 'corfu-quit
    "C-q" 'corfu-quick-complete
    "C-z" 'cape-codeium)
  (with-eval-after-load 'evil
    (evil-make-overriding-map corfu-map)
    (advice-add 'corfu--setup :after 'evil-normalize-keymaps)
    (advice-add 'corfu--teardown :after 'evil-normalize-keymaps))
  ;; https://github.com/minad/corfu?tab=readme-ov-file#completing-in-the-minibuffer
  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input)
                (eq (current-local-map) read-passwd-map))
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1))))
#+end_src
** embark
#+begin_src emacs-lisp
(e:package-config! embark
  :config
  (general-def minibuffer-mode-map
    :prefix "C-c"
    "C-a" 'embark-act
    "C-c" 'embark-collect
    "C-d" 'embark-dwim
    "C-e" 'embark-export))
#+end_src
** embark-consult
#+begin_src emacs-lisp
(e:package-config! embark-consult)
#+end_src
** fussy
#+begin_src emacs-lisp
(e:package-config! fussy
  :init
  (setq completion-styles '(fussy orderless))
  (setq completion-category-defaults nil)
  (setq completion-category-overrides nil)
  :defer-config
  (e:variable! fussy-filter-fn 'fussy-filter-orderless)
  (e:variable! fussy-score-fn 'fussy-fzf-native-score)
  (e:variable! fussy-max-candidate-limit 5000))
#+end_src
** fzf-native
#+begin_src emacs-lisp
(e:package-config! (fzf-native :host github :repo "dangduc/fzf-native" :files (:defaults "bin"))
  :config
  (fzf-native-load-dyn))
#+end_src
** kind-icon
#+begin_src emacs-lisp
(e:package-config! kind-icon
  :after (corfu)
  :defvar (corfu-margin-formatters)
  :config
  (e:variable! kind-icon-default-face 'corfu-default)
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src
** marginalia
#+begin_src emacs-lisp
(e:package-config! marginalia
  :config
  (marginalia-mode 1))
#+end_src
** orderless
#+begin_src emacs-lisp
(e:package-config! orderless
  :commands (orderless-migemo)
  :init
  (e:variable! orderless-matching-styles '(orderless-literal orderless-regexp orderless-migemo))
  :defer-config
  (defun orderless-migemo (component)
    (when (fboundp 'migemo-get-pattern)
      (let ((pattern (migemo-get-pattern component)))
        (condition-case nil
            (progn (string-match-p pattern "") pattern)
          (invalid-regexp nil))))))
#+end_src
** vertico
#+begin_src emacs-lisp
(e:package-config! vertico
  :priority :high
  :config
  (e:variable! vertico-count 20)
  (e:variable! vertico-cycle t)
  (general-def vertico-map
    "C-l" 'vertico-directory-up)
  (vertico-mode 1))
#+end_src
* Config: Org
** evil-org
#+begin_src emacs-lisp
(e:package-config! evil-org
  :hook (org-mode-hook . evil-org-mode))
#+end_src
** org-support
#+begin_src emacs-lisp
(e:deffered-config! org-support
  :defun (org-support/archive-file org-support/note-file org-support/tasks-file)
  :defvar (org-directory)
  :config
  (defun org-support/archive-file ()
    (require 'org)
    (f-expand (format-time-string "archives/%Y.org") org-directory))
  (defun org-support/tasks-file ()
    (require 'org)
    (f-expand "tasks.org" org-directory))
  (defun org-support/popup-tasks ()
    (interactive)
    (display-buffer (find-file-noselect (org-support/tasks-file))))
  (defun org-support/note-file ()
    (f-expand "note.org" org-directory))
  (defun org-support/popup-note ()
    (interactive)
    (display-buffer (find-file-noselect (org-support/note-file)))))
#+end_src
** org
#+begin_src emacs-lisp
(e:deffered-config! org
  :defer-config
  (e:variable! org-directory (f-expand "~/org/"))
  (e:variable! org-default-notes-file (org-support/note-file))
  (e:variable! org-startup-folded nil)
  (e:variable! org-startup-indented t)
  (e:variable! org-tags-column 0)
  (e:variable! org-todo-keywords '((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d)")
                                   (sequence "WAITING(w)" "HOLD(h)" "|" "CANCELLED(c)")))
  (e:major-mode-key-def org-mode
    "," 'org-ctrl-c-ctrl-c))
#+end_src
** org-agenda
#+begin_src emacs-lisp
(e:deffered-config! org-agenda
  :after (org)
  :config
  (e:variable! org-agenda-current-time-string "← now")
  (e:variable! org-agenda-entry-text-leaders (s-concat (s-repeat 25 " ") "│ "))
  (e:variable! org-agenda-entry-text-maxlines 20)
  (e:variable! org-agenda-files (list (org-support/note-file)
                                      (org-support/tasks-file)
                                      (f-parent (org-support/archive-file))))
  (e:variable! org-agenda-span 28)
  (e:variable! org-agenda-time-grid '((daily today require-timed)
                                      (800 1000 1200 1400 1600 1800 2000)
                                      "      "
                                      "────────────────")))
#+end_src
** org-bullets
#+begin_src emacs-lisp
(e:package-config! org-bullets
  :after (org)
  :hook (org-mode-hook . org-bullets-mode))
#+end_src
** org-clock
#+begin_src emacs-lisp
(e:deffered-config! org-clock
  :after (org)
  :config
  (e:variable! org-clock-persist t)
  (org-clock-persistence-insinuate))
#+end_src
** org-faces
#+begin_src emacs-lisp
(e:deffered-config! org-faces
  :after (org)
  :config
  (e:variable! org-todo-keyword-faces
               '(("TODO"    . org-warning)
                 ("WAITING" . org-done)
                 ("HOLD"    . org-done)))
  (set-face-attribute 'org-todo nil :foreground "#00ff00")
  (set-face-attribute 'org-done nil :foreground "#696969")
  (set-face-attribute 'org-headline-done nil :foreground "#696969")
  (set-face-attribute 'org-headline-todo nil :foreground "#00ff00")
  (set-face-attribute 'org-level-1 nil :height 1.0)
  (set-face-attribute 'org-level-2 nil :height 1.0)
  (set-face-attribute 'org-level-3 nil :height 1.0))
#+end_src
** org-refile
#+begin_src emacs-lisp
(e:deffered-config! org-refile
  :after (org)
  :config
  (e:variable! org-refile-targets
               '((org-support/tasks-file   :level . 1)
                 (org-support/archive-file :level . 1)))
  (e:variable! org-refine-use-outline-path 'file))
#+end_src
** org-src
#+begin_src emacs-lisp
(e:deffered-config! org-src
  :after (org)
  :config
  (e:variable! org-edit-src-content-indentation 0)
  (e:variable! org-src-window-setup 'split-window-below))
#+end_src
* Config: Packages
** ace-window
#+begin_src emacs-lisp
(e:package-config! ace-window
  :defer-config
  (e:variable! aw-keys (number-sequence ?1 ?9))
  (e:variable! aw-scope 'frame))
#+end_src
** affe
#+begin_src emacs-lisp
(e:package-config! affe
  :defvar (affe-find-command)
  :defer-config
  (e:variable! affe-find-command (or (executable-find "fd") affe-find-command))
  (e:variable! affe-regexp-function 'orderless-pattern-compiler)
  (e:variable! affe-highlight-function 'orderless--highlight))
#+end_src
** atomic-chrome
#+begin_src emacs-lisp
(e:package-config! atomic-chrome
  :config
  (atomic-chrome-start-server))
#+end_src
** apheleia
#+begin_src emacs-lisp :lexical no
(e:package-config! apheleia
  :defvar (apheleia-formatters apheleia-mode-alist)
  :defer-config
  ;; formatters
  (setf (alist-get 'rubocop apheleia-formatters)
        '((if (e:bundle-exists "rubocop")
              '("bundle" "exec" "rubocop")
            "rubocop")
          file "--autocorrect" "--stderr" "--format" "quiet" "--fail-level" "fatal"))
  ;; mode-alist
  (setf (alist-get 'ruby-mode apheleia-mode-alist) '(rubocop)))
#+end_src
** avy
#+begin_src emacs-lisp
(e:package-config! avy
  :config
  (with-eval-after-load 'evil
    (general-def '(normal motion)
      "S" 'evil-avy-goto-word-0
      "gj" 'evil-avy-goto-line-below
      "gk" 'evil-avy-goto-line-above))
  :defer-config
  (e:variable! avy-keys (number-sequence ?a ?z))
  (e:variable! avy-all-windows t)
  (e:variable! avy-all-windows-alt nil))
#+end_src
** browse-at-remote
#+begin_src emacs-lisp
(e:package-config! browse-at-remote)
#+end_src
** chezmoi
#+begin_src emacs-lisp :lexical no
(e:package-config! chezmoi
  :config
  (require 'chezmoi))
#+end_src
** consult-flycheck
#+begin_src emacs-lisp :lexical no
(e:package-config! consult-flycheck)
#+end_src
** consult-projectile
#+begin_src emacs-lisp :lexical no
(e:package-config! consult-projectile)
#+end_src
** consult-todo
#+begin_src emacs-lisp :lexical no
(e:package-config! (consult-todo :host github :repo "liuyinz/consult-todo"))
#+end_src
** devdocs
#+begin_src emacs-lisp :lexical no
(e:package-config! devdocs)
#+end_src
** difftastic
#+begin_src emacs-lisp :lexical no
(e:package-config! difftastic
  :config
  (with-eval-after-load 'magit-diff
    (transient-append-suffix 'magit-diff '(-1 -1)
      [("D" "Difftastic diff (dwim)" difftastic-magit-diff)
       ("S" "Difftastic show" difftastic-magit-show)])))
#+end_src
** doom-modeline
#+begin_src emacs-lisp
(e:package-config! doom-modeline
  :config
  (e:variable! doom-modeline-buffer-file-name-style 'buffer-name)
  (e:variable! doom-modeline-minor-modes t)
  (doom-modeline-mode 1))
#+end_src
** dtrt-indent
#+begin_src emacs-lisp :lexical no
(e:package-config! dtrt-indent
  :defun (dtrt-indent-adapt)
  :hook (prog-mode-hook . setup-dtrt-indent)
  :defer-config
  (defun setup-dtrt-indent ()
    (dtrt-indent-mode 1)
    (dtrt-indent-adapt)))
#+end_src
** dumb-jump
#+begin_src emacs-lisp :lexical no
(e:package-config! dumb-jump
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src
** editorconfig
#+begin_src emacs-lisp :lexical no
(e:package-config! editorconfig
  :config
  (editorconfig-mode 1))
#+end_src
** elisp-demos
#+begin_src emacs-lisp
(e:package-config! elisp-demos
  :advice ((:after describe-function-1 elisp-demos-advice-describe-function-1)
           (:after helpful-update      elisp-demos-advice-helpful-update)))
#+end_src
** expand-region
#+begin_src emacs-lisp
(e:package-config! expand-region)
#+end_src
** flycheck
#+begin_src emacs-lisp :lexical no
(e:package-config! flycheck
  :commands (e:flycheck-copy-error-ids)
  :defun (flycheck-error-id flycheck-overlay-errors-at)
  :init
  (global-flycheck-mode 1)
  (defun e:flycheck-copy-error-ids ()
    (interactive)
    (let ((messages (->> (flycheck-overlay-errors-at (point))
                         (-map #'flycheck-error-id)
                         (-uniq)
                         (-non-nil))))
      (when messages
        (kill-new (string-join messages ", "))
        (message (string-join messages ", "))))))
#+end_src
** git-gutter
#+begin_src emacs-lisp :lexical no
(e:package-config! git-gutter
  :config
  (global-git-gutter-mode 1))
#+end_src
** grugru
#+begin_src emacs-lisp :lexical no
(e:package-config! grugru)
#+end_src
** helm
#+begin_src emacs-lisp
(e:package-config! helm
  :bind (([remap eval-expression] . helm-eval-expression-with-eldoc)))
#+end_src
** helpful
#+begin_src emacs-lisp
(e:package-config! helpful)
#+end_src
** highlight-indentation
#+begin_src emacs-lisp
(e:package-config! highlight-indentation
  :commands (highlight-indentation-mode-on)
  :config
  (e:variable! highlight-indentation-offset 2)
  :defer-config
  (set-face-attribute 'highlight-indentation-face nil :background "#202020" :inherit nil)
  (e:define-minor-mode-switch highlight-indentation-mode))
#+end_src
** hl-todo
#+begin_src emacs-lisp :lexical no
(e:package-config! hl-todo
  :config
  (global-hl-todo-mode 1))
#+end_src
** jinx
#+begin_src emacs-lisp :lexical no
(e:package-config! jinx
  :defvar (jinx-exclude-regexps)
  :hook (prog-mode-hook . jinx-mode)
  :config
  (e:variable! jinx-languages "en_US")
  ;; https://github.com/minad/jinx/issues/4#issuecomment-1484786256
  (let ((re (alist-get t jinx-exclude-regexps)))
    (add-to-list 're "\\cc")
    (setf (alist-get t jinx-exclude-regexps) re)))
#+end_src
** locale-eaw
#+begin_src emacs-lisp :lexical no
(e:package-config! (eaw :host github :repo "hamano/locale-eaw")
  :commands (eaw-fullwidth)
  :init
  (eaw-fullwidth))
#+end_src
** macrostep
#+begin_src emacs-lisp :lexical no
(e:package-config! macrostep
  :config
  (e:major-mode-key-def (emacs-lisp-mode lisp-interaction-mode)
    "d" "debug"
    "dm" 'macrostep-mode)
  (hercules-def
   :toggle-funs #'macrostep-mode
   :keymap 'macrostep-keymap))
#+end_src
** magit
*** magit
#+begin_src emacs-lisp :lexical no
(e:package-config! magit
  :advice (:override magit-repos-alist magit-repos-alist@override)
  :defun (magit-add-section-hook magit-list-repos magit-list-repos-uniquify)
  :defer-config
  (e:variable! magit-delete-by-moving-to-trash nil)
  (e:variable! magit-diff-refine-hunk 'all)
  (e:variable! magit-diff-refine-ignore-whitespace t)
  (e:variable! magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (e:variable! magit-log-margin '(t "%Y-%m-%d %H:%M" magit-log-margin-width t 15))
  (--each '(magit-insert-skip-worktree-files magit-insert-modules-overview)
    (magit-add-section-hook 'magit-status-sections-hook it 'magit-insert-unpulled-from-upstream t))
  (let ((argments '("--graph" "-n256" "--decorate" "--date-order" "--show-signature")))
    (put 'magit-log-mode 'magit-log-default-arguments argments)
    (put 'magit-log-select-mode 'magit-log-default-arguments argments))
  ;; リポジトリの一覧表示にパスをつける
  (defun magit-repos-alist@override (&rest _)
    (magit-list-repos-uniquify
     (--map (cons (f-short it) it)
            (magit-list-repos))))
  ;; `ghq' で管理しているディレクトリを探索の対象にする
  (when (executable-find "ghq")
    (e:variable! magit-repository-directories
                 (->> (kllib:shell-command-to-list "ghq root --all")
                      (--map (cons it 5))))))
#+end_src
*** magit-delta
#+begin_src emacs-lisp :lexical no
(e:package-config! magit-delta
  :advice (:around magit-delta-call-delta-and-convert-ansi-escape-sequences magit-delta-call-delta-and-convert-ansi-escape-sequences@auto-disable)
  :defvar (magit-delta-mode)
  :hook (magit-mode-hook . magit-delta-mode)
  :defer-config
  ;; https://github.com/dandavison/magit-delta/issues/9#issuecomment-795435781
  (defvar nth/magit-delta-point-max 50000)
  (defun magit-delta-call-delta-and-convert-ansi-escape-sequences@auto-disable (fn &rest args)
    (if (<= (point-max) nth/magit-delta-point-max)
        (apply fn args)
      (magit-delta-mode -1)))
  (add-hook 'magit-post-refresh-hook
            (defun nth/magit-delta-auto-enable (&rest _)
              (when (and (not magit-delta-mode)
                         (<= (point-max) nth/magit-delta-point-max))
                (magit-delta-mode +1)))))
#+end_src
** migemo
#+begin_src emacs-lisp :lexical no
(e:package-config! migemo
  :config
  (require 'migemo)
  (e:variable! migemo-user-dictionary nil)
  (e:variable! migemo-regex-dictionary nil)
  (e:if! (eq system-type 'darwin)
    (e:variable! migemo-dictionary "/usr/local/share/migemo/utf-8/migemo-dict"))
  (e:if! (eq system-type 'gnu/linux)
    (e:variable! migemo-dictionary "/usr/share/cmigemo/utf-8/migemo-dict")))
#+end_src
** minions
#+begin_src emacs-lisp :lexical no
(e:package-config! minions
  :config
  (minions-mode 1))
#+end_src
** open-junk-file
#+begin_src emacs-lisp :lexical no
(e:package-config! open-junk-file
  :config
  (e:variable! open-junk-file-format (f-expand "junk/%Y/%Y%m%d%H%M%S." no-littering-var-directory)))
#+end_src
** pdf-tools
#+begin_src emacs-lisp :lexical no
(e:package-config! pdf-tools)
#+end_src
** persistent-scratch
#+begin_src emacs-lisp :lexical no
(e:package-config! persistent-scratch
  :priority :high
  :config
  (persistent-scratch-setup-default))
#+end_src
** prodigy
*** prodigy
#+begin_src emacs-lisp :lexical no
(e:package-config! prodigy
  :defun (prodigy-find-service prodigy-start-service)
  :defer-config
  (e:variable! prodigy-view-buffer-maximum-size 2048)
  (e:variable! prodigy-view-truncate-by-default t)
  (prodigy-define-tag
    :name 'rails
    :ready-message "Use Ctrl-C to stop"))
#+end_src
*** prodigy-with-vterm
#+begin_src emacs-lisp :lexical no
(e:deffered-config! prodigy-with-vterm
  :advice (:around prodigy-start-service ad:prodigy-start-service@with-vterm)
  :after (prodigy)
  :defvar (vterm--process)
  :defun (ad:start-process@with-vterm vterm--internal)
  :config
  (defun ad:start-process@with-vterm (name buffer program &rest args)
    (let* ((command (s-join " " (cons program args)))
           (vterm-buffer-name (format "*vterm-%s*" name))
           (vterm-shell (format "zsh -c '%s'" command)))
      (let* ((cwd (plist-get (prodigy-find-service name) :cwd))
             (sock-file (f-expand ".overmind.sock" cwd)))
        (when (f-exists? sock-file)
          (message "delete: %s" sock-file)
          (delete-file sock-file)))
      (with-current-buffer (vterm--internal #'ignore)
        vterm--process)))
  (defun ad:prodigy-start-service@with-vterm (func &rest args)
    (when (require 'vterm nil t)
      (advice-add 'start-process :override #'ad:start-process@with-vterm))
    (prog1 (apply func args)
      (advice-remove 'start-process #'ad:start-process@with-vterm))))
#+end_src
** projectile
#+begin_src emacs-lisp :lexical no
(e:package-config! projectile
  :commands (e:setup-projectile-known-projects)
  :defun (projectile-project-vcs)
  :defvar (projectile-known-projects)
  :defer-config
  (defun e:setup-projectile-known-projects ()
    (when (executable-find "ghq")
        (setq projectile-known-projects
            (->> projectile-known-projects
                (--remove (eq (projectile-project-vcs it) 'none))
                (-union (-map 'f-short (kllib:shell-command-to-list "ghq list --full-path")))
                (-map 'file-name-as-directory)
                (-sort 's-less?)
                (-distinct)))))
  (e:setup-projectile-known-projects))
#+end_src
** rainbow-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! rainbow-mode)
#+end_src
** separedit
#+begin_src emacs-lisp :lexical no
(e:package-config! separedit
  :config
  (general-def prog-mode-map
    "C-c '" 'separedit)
  :defer-config
  (e:variable! separedit-preserve-string-indentation t))
#+end_src
** shackle
#+begin_src emacs-lisp :lexical no
(e:package-config! shackle
  :advice ((:after shackle-display-buffer-action ad:shackle-display-buffer-action@save-windows)
           (:before keyboard-quit ad:keyboard-quit@shackle-auto-close))
  :defvar (shackle-last-window)
  :config
  (e:variable! shackle-rules
               '(;;
                 ("*Backtrace*"       :align bottom :ratio 0.3 :select t)
                 ("*Flycheck errors*" :align bottom :ratio 0.3 :select t)
                 ("*Help*"            :align bottom :ratio 0.3 :select t)
                 ;;
                 ("*Async Shell Command*"          :align bottom :ratio 0.3)
                 ("*Bundler*"                      :align bottom :ratio 0.3)
                 ("*General Keybindings*"          :align bottom :ratio 0.3)
                 ("*Warnings*"                     :align bottom :ratio 0.3)
                 ("*projectile-rails-compilation*" :align bottom :ratio 0.3)
                 ("*rspec-compilation*"            :align bottom :ratio 0.3)
                 ("*trace-output*"                 :align bottom :ratio 0.3)
                 ))
  (shackle-mode 1)
  :defer-config
  (defvar e:shackle-auto-close-windows nil)
  (defun ad:shackle-display-buffer-action@save-windows (&rest _)
    (setq e:shackle-auto-close-windows (-filter #'window-live-p e:shackle-auto-close-windows))
    (add-to-list 'e:shackle-auto-close-windows shackle-last-window))
  (defun ad:keyboard-quit@shackle-auto-close (&rest _)
    (ignore-errors
      (-each e:shackle-auto-close-windows 'delete-window))
    (setq e:shackle-auto-close-windows nil)))
#+end_src
** shell-pop
#+begin_src emacs-lisp :lexical no
(e:package-config! shell-pop
  :advice (:around shell-pop ad:shell-pop@auto-session-name)
  :defvar (shell-pop-shell-type)
  :config
  (e:variable! shell-pop-shell-type '("vterm" "*vterm-default*" #'vterm))
  :defer-config
  (e:variable! shell-pop-autocd-to-working-dir nil)
  (e:variable! shell-pop-full-span t)
  (e:variable! shell-pop-window-size 50)
  (defun ad:shell-pop@auto-session-name (func &rest args)
    (let* ((tab (tab-bar--current-tab))
           (identifier (if (alist-get 'explicit-name tab)
                           (alist-get 'name tab)
                         "default"))
           (shell-pop-internal-mode-buffer (format "*vterm-%s*" identifier))
           (vterm-shell (format "tmux new -A -s emacs-%s" identifier)))
      (apply func args))))
#+end_src
** smartparens
#+begin_src emacs-lisp :lexical no
(e:package-config! smartparens
  :defun (sp-local-pair)
  :config
  (e:variable! sp-cancel-autoskip-on-backward-movement nil)
  (e:variable! sp-highlight-pair-overlay nil)
  (e:variable! sp-highlight-wrap-overlay nil)
  (e:variable! sp-highlight-wrap-tag-overlay nil)
  (e:variable! sp-show-pair-from-inside t)
  (smartparens-global-mode 1)
  (show-smartparens-global-mode 1)
  (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
  (sp-local-pair 'lisp-interaction-mode "'" nil :actions nil))
#+end_src
** symbol-overlay
#+begin_src emacs-lisp :lexical no
(e:package-config! symbol-overlay
  :defvar (symbol-overlay-map)
  :defer-config
  (setq symbol-overlay-map (make-sparse-keymap)))
#+end_src
** transient
#+begin_src emacs-lisp :lexical no
(e:package-config! transient
  :defer-config
  (e:variable! transient-default-level 7)
  (e:var! transient-values-file "transient-values.el"))
#+end_src
** undo-fu
#+begin_src emacs-lisp :lexical no
(e:package-config! undo-fu
  :config
  (e:variable! evil-undo-system 'undo-fu))
#+end_src
** visual-regexp
#+begin_src emacs-lisp :lexical no
(e:package-config! visual-regexp
  :bind ([remap query-replace] . vr/query-replace))
#+end_src
** vlf
#+begin_src emacs-lisp :lexical no
(e:package-config! vlf)
#+end_src
** vterm
#+begin_src emacs-lisp :lexical no
(e:package-config! vterm
  :defer-config
  (general-def vterm-mode-map
    "<wheel-down>" 'ignore
    "<wheel-up>" 'ignore
    "C-c C-g" 'keyboard-quit
    "C-g" 'vterm--self-insert
    "C-j" 'e:vterm-input-something)
  (general-def 'insert vterm-mode-map
    "<escape>" 'vterm-send-escape
    "C-z" 'vterm--self-insert)
  (e:variable! vterm-max-scrollback 20000)
  (e:variable! vterm-shell "tmux new -A -s emacs-default")
  (defun e:vterm-input-something ()
    (interactive)
    (let ((input (read-string "input: ")))
      (with-no-warnings (vterm-send-string input)))))
#+end_src
** wakatime-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! wakatime-mode
  :defvar (wakatime-api-key wakatime-cli-path)
  :preface
  (e:variable! wakatime-cli-path (executable-find "wakatime-cli"))
  :if (and wakatime-cli-path
           (bound-and-true-p wakatime-api-key))
  :config
  (global-wakatime-mode 1))
#+end_src
** wgrep
#+begin_src emacs-lisp :lexical no
(e:package-config! wgrep)
#+end_src
** which-key
#+begin_src emacs-lisp :lexical no
(e:deffered-config! which-key
  :config
  (e:variable! which-key-idle-delay 0.4)
  (e:variable! which-key-idle-secondary-delay 0.01)
  (e:variable! which-key-min-display-lines 6)
  (e:variable! which-key-show-early-on-C-h t)
  (e:variable! which-key-sort-order 'which-key-key-order-alpha)
  (which-key-mode 1))
#+end_src
** winum
#+begin_src emacs-lisp :lexical no
(e:package-config! winum
  :config
  (winum-mode 1))
#+end_src
* Config: Languages
** Tools
*** lsp-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! lsp-mode
  :defer-config
  (e:variable! lsp-auto-execute-action nil)
  (e:variable! lsp-completion-provider :none)
  (e:variable! lsp-enable-file-watchers nil)
  (e:variable! lsp-enable-snippet nil)
  (e:variable! lsp-file-watch-threshold 100000)
  (e:variable! lsp-imenu-sort-methods '(position))
  (e:variable! lsp-modeline-code-actions-enable nil)
  (e:minor-mode-key-def lsp-mode
    "=" "format"
    "=b" 'lsp-format-buffer
    "=o" 'lsp-organize-imports
    "=r" 'lsp-format-region
    "a" "code action"
    "aa" 'lsp-execute-code-action
    "b" "backend"
    "bd" 'lsp-describe-session
    "br" 'lsp-workspace-restart
    "bs" 'lsp-workspace-shutdown
    "bv" 'lsp-version
    "r" "refactor"
    "rr" 'lsp-rename))
#+end_src
*** lsp-ui
#+begin_src emacs-lisp :lexical no
(e:package-config! lsp-ui
  :defer-config
  (e:variable! lsp-ui-doc-delay 2.0)
  (e:variable! lsp-ui-doc-include-signature t)
  (e:variable! lsp-ui-doc-position 'at-point)
  (e:variable! lsp-ui-doc-show-with-cursor t)
  (e:variable! lsp-ui-sideline-enable nil))
#+end_src
*** lsp-rubocop
#+begin_src emacs-lisp :lexical no
(e:deffered-config! lsp-rubocop
  :defun (e:bundle-exists)
  :advice (:before lsp-rubocop--build-command ad:lsp-rubocop--build-command@auto-detect)
  :defer-config
  (e:eval!
    (let ((rubocop-ls (gethash 'rubocop-ls lsp-clients)))
      (setf (lsp--client-add-on? rubocop-ls) t)))
  (defun ad:lsp-rubocop--build-command@auto-detect ()
    (setq-local lsp-rubocop-use-bundler (e:bundle-exists "rubocop"))))
#+end_src
*** lsp-solargraph
#+begin_src emacs-lisp :lexical no
(e:deffered-config! lsp-solargraph
  :defun (e:bundle-exists)
  :advice (:before lsp-solargraph--build-command ad:lsp-solargraph--build-command@auto-detect)
  :defer-config
  (e:variable! lsp-solargraph-library-directories '("~/.asdf/installs/ruby"))
  (defun ad:lsp-solargraph--build-command@auto-detect ()
    (setq-local lsp-solargraph-use-bundler (e:bundle-exists "solargraph"))))
#+end_src
*** dap-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! dap-mode)
#+end_src
*** tree-sitter
#+begin_src emacs-lisp :lexical no
(e:package-config! treesit-auto
  :commands (treesit-auto-add-to-auto-mode-alist global-treesit-auto-mode)
  :init
  (e:variable! treesit-auto-install t)
  (e:variable! treesit-language-source-alist
               '((vue "https://github.com/ikatyang/tree-sitter-vue")))
  (treesit-auto-add-to-auto-mode-alist)
  (global-treesit-auto-mode 1))
#+end_src
** Ruby
*** ruby-ts-mode
#+begin_src emacs-lisp :lexical no
(e:deffered-config! ruby-ts-mode
  :hook (ruby-ts-mode-hook . lsp-deferred)
  :mode "\\.csb\\'"
  :defer-config
  (e:major-mode-key-def ruby-ts-mode
    "b" "bundle"
    "bc" 'bundle-check
    "bi" 'bundle-install
    "bo" 'bundle-open
    "bu" 'bundle-update
    "bx" 'bundle-exec
    "r" "refactor"
    "r\"" 'ruby-toggle-string-quotes
    "r'" 'ruby-toggle-string-quotes
    "r{" 'ruby-toggle-block
    "r}" 'ruby-toggle-block)
  (grugru-define-multiple
    (ruby-ts-mode
     (symbol "have_button" "have_no_button")
     (symbol "have_content" "have_no_content")
     (symbol "have_link" "have_no_link")
     (symbol "if" "unless")
     (symbol "let" "let!")
     (symbol "to" "not_to")
     (symbol "true" "false")))
  (defvar e:bundle-exists-cache (ht-create 'equal))
  (defun e:clear-bundle-exists-cache ()
    (interactive)
    (ht-clear! e:bundle-exists-cache))
  (defun e:bundle-exists (name)
    (let ((key (format "%s@%s" name (or (kllib:project-root) (buffer-name)))))
      (unless (ht-get e:bundle-exists-cache key)
        (ht-set e:bundle-exists-cache key (call-process-shell-command (format "bundle info %s" name))))
      (zerop (ht-get e:bundle-exists-cache key)))))
#+end_src
*** haml-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! haml-mode
  :hook (haml-mode-hook . highlight-indentation-mode-on))
#+end_src
*** bundler
#+begin_src emacs-lisp :lexical no
(e:package-config! bundler)
#+end_src
*** projectile-rails
#+begin_src emacs-lisp :lexical no
(e:package-config! projectile-rails
  :config
  (e:var! rake-cache-file "rake.cache")
  (let ((exts '("html" "erb" "haml" "slim"
                "js" "coffee" "ts"
                "css" "scss" "sass" "less"
                "json" "builder" "jbuilder" "rabl"
                "csb" "axlsx")))
    (e:variable! projectile-rails-views-re (concat "\\." (regexp-opt exts))))
  (e:variable! rake-completion-system 'completing-read-default)
  (projectile-rails-global-mode 1)
  (e:minor-mode-key-def projectile-rails-mode
    "f" "rails"
    "f:" '("rake" . projectile-rails-rake)
    "fc" "generate/destroy"
    "fcc" '("generate" . projectile-rails-generate)
    "fcd" '("destroy" . projectile-rails-destroy)
    "ff" "find"
    "ff@" '("mailer" . projectile-rails-find-mailer)
    "ffa" '("locale" . projectile-rails-find-locale)
    "ffb" '("job" . projectile-rails-find-job)
    "ffc" '("controller" . projectile-rails-find-controller)
    "ffe" '("environment" . projectile-rails-find-environment)
    "fff" '("feature" . projectile-rails-find-feature)
    "ffh" '("helper" . projectile-rails-find-helper)
    "ffi" '("initializer" . projectile-rails-find-initializer)
    "ffj" '("javascript" . projectile-rails-find-javascript)
    "ffl" '("lib" . projectile-rails-find-lib)
    "ffm" '("model" . projectile-rails-find-model)
    "ffn" '("migration" . projectile-rails-find-migration)
    "ffo" '("log" . projectile-rails-find-log)
    "ffp" '("spec" . projectile-rails-find-spec)
    "ffr" '("rake task" . projectile-rails-find-rake-task)
    "ffs" '("stylesheet" . projectile-rails-find-stylesheet)
    "fft" '("test" . projectile-rails-find-test)
    "ffu" '("fixture" . projectile-rails-find-fixture)
    "ffv" '("view" . projectile-rails-find-view)
    "ffw" '("webpack" . projectile-rails-find-webpack)
    "ffy" '("layout" . projectile-rails-find-layout)
    "fg" "goto"
    "fg." '("point" . projectile-rails-goto-file-at-point)
    "fgc" '("controller" . projectile-rails-find-current-controller)
    "fgd" '("schema" . projectile-rails-goto-schema)
    "fge" '("seeds" . projectile-rails-goto-seeds)
    "fgg" '("gemfile" . projectile-rails-goto-gemfile)
    "fgh" '("helper" . projectile-rails-find-current-helper)
    "fgj" '("javascript" . projectile-rails-find-current-javascript)
    "fgm" '("model" . projectile-rails-find-current-model)
    "fgn" '("migration" . projectile-rails-find-current-migration)
    "fgp" '("spec" . projectile-rails-find-current-spec)
    "fgr" '("routes" . projectile-rails-goto-routes)
    "fgs" '("stylesheet" . projectile-rails-find-current-stylesheet)
    "fgt" '("test" . projectile-rails-find-current-test)
    "fgu" '("fixture" . projectile-rails-find-current-fixture)
    "fgv" '("view" . projectile-rails-find-current-view)
    "fgz" '("helper" . projectile-rails-goto-spec-helper)))
#+end_src
*** rails-routes
#+begin_src emacs-lisp :lexical no
(e:package-config! rails-routes
  :defer-config
  (e:var! rails-routes-cache-path "rails-routes"))
#+end_src
*** rspec-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! rspec-mode
  :defer-config
  (e:minor-mode-key-def rspec-mode
    "t" "test"
    "t TAB" 'rspec-toggle-spec-and-target
    "ta" 'rspec-verify-all
    "tb" 'rspec-verify
    "tc" 'rspec-verify-continue
    "te" 'rspec-toggle-example-pendingness
    "tf" 'rspec-verify-method
    "tl" 'rspec-run-last-failed
    "tm" 'rspec-verify-matching
    "tr" 'rspec-rerun
    "tt" 'rspec-verify-single
    "t~" 'rspec-toggle-spec-and-target-find-example))
#+end_src
** TypeScript/JavaScript
*** typescript-ts-mode
#+begin_src emacs-lisp :lexical no
(e:deffered-config! typescript-ts-mode
  :hook (typescript-ts-mode-hook . lsp-deferred))
#+end_src
*** tsx-ts-mode
#+begin_src emacs-lisp :lexical no
(e:deffered-config! tsx-ts-mode
  :hook (tsx-ts-mode-hook . lsp-deferred))
#+end_src
*** vue-ts-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! (vue-ts-mode :host github :repo "8uff3r/vue-ts-mode")
  :hook (vue-ts-mode-hook . lsp-deferred)
  :mode "\\.vue\\'")
#+end_src
*** yarn
#+begin_src emacs-lisp :lexical no
(e:package-config! (yarn :host github :repo "jmfirth/yarn.el")
  :commands (yarn-install
             yarn-self-udpate
             yarn-update
             yarn-upgrade))
#+end_src
** HTML/CSS
*** web-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! web-mode
  :mode "\\.erb\\'"
  :config
  (e:variable! web-mode-enable-auto-indentation nil))
#+end_src
*** sass-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! sass-mode
  :hook (sass-mode-hook . rainbow-mode))
#+end_src
*** scss-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! scss-mode
  :hook (scss-mode-hook . rainbow-mode))
#+end_src
*** emmet-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! emmet-mode
  :hook ((haml-mode-hook . emmet-mode)
         (tsx-ts-mode-hook . emmet-mode)
         (vue-ts-mode-hook . emmet-mode)
         (web-mode-hook . emmet-mode))
  :defer-config
  (general-def emmet-mode-keymap
    "<C-return>" nil
    "C-c C-j" 'emmet-expand-line
    "C-j" nil))
#+end_src
** Text
*** yaml-ts-mode
#+begin_src emacs-lisp :lexical no
(e:package-config! yaml-mode
  :commands (yaml-indent-line))
(e:deffered-config! yaml-ts-mode
  :hook ((yaml-ts-mode-hook . lsp-deferred)
         (yaml-ts-mode-hook . highlight-indentation-mode-on))
  :defer-config
  (general-def yaml-ts-mode-map
    "TAB" 'yaml-indent-line))
#+end_src
* Config: Keybinds
** Space
*** support
#+begin_src emacs-lisp :lexical no
(defsubst e:key-def-prefix (&optional key)
  (s-trim-right (format "SPC %s" (or key ""))))
(defsubst e:key-def-non-normal-prefix (&optional key)
  (s-trim-right (format "M-m %s" (or key ""))))
(general-create-definer e:key-def
  :states '(motion normal visual insert emacs)
  :keymaps 'override)

(general-def '(motion normal visual)
  "M-m" (general-simulate-key "SPC"))
#+end_src
*** root
#+begin_src emacs-lisp :lexical no
(defun e:switch-to-last-buffer ()
  (interactive)
  (if-let ((buffer (caar (window-prev-buffers))))
      (switch-to-buffer buffer)))

(e:key-def
  :keymaps 'override
  :prefix (e:key-def-prefix)
  :non-normal-prefix (e:key-def-non-normal-prefix)
  :prefix-command 'e:root-command
  :prefix-map 'e:root-command-map
  "SPC" '(execute-extended-command :wk "M-x")
  "TAB" '(e:switch-to-last-buffer :wk "Last buffer")
  "!" 'shell-command
  "%" 'query-replace
  "&" 'async-shell-command
  "*" 'consult-ripgrep-dwim
  "/" 'consult-ripgrep
  ";" 'evilnc-comment-operator
  "^" 'ace-window
  "|" 'shell-command-on-region
  "1" '(winum-select-window-1 :wk "window 1")
  "2" '(winum-select-window-2 :wk "window 2")
  "3" '(winum-select-window-3 :wk "window 3")
  "4" '(winum-select-window-4 :wk "window 4")
  "5" '(winum-select-window-5 :wk "window 5")
  "6" '(winum-select-window-6 :wk "window 6")
  "7" '(winum-select-window-7 :wk "window 7")
  "8" '(winum-select-window-8 :wk "window 8")
  "9" '(winum-select-window-9 :wk "window 9")
  "m" '(:ignore t :wk "mode")
  "u" 'universal-argument
  "v" 'er/expand-region)
#+end_src
*** [F] frame
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "F")
  :non-normal-prefix (e:key-def-non-normal-prefix "F")
  :prefix-command 'e:frame-command
  :prefix-map 'e:frame-command-map
  "" '(:ignore t :wk "frame")
  "D" 'delete-other-frames
  "d" 'delete-frame
  "n" 'make-frame
  "o" 'other-frame)
#+end_src
*** [a] application...
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "a")
  :non-normal-prefix (e:key-def-non-normal-prefix "a")
  :prefix-command 'e:application-command
  :prefix-map 'e:application-command-map
  "" '(:ignore t :wk "application")
  "c" '(:ignore t :wk "chezmoi")
  "cd" 'chezmoi-diff
  "cf" 'chezmoi-find
  "co" 'chezmoi-open-other
  "cs" 'chezmoi-sync-files
  "ct" 'chezmoi-template-buffer-display
  "cw" 'chezmoi-write
  "e" '(:ignore t :wk "elpaca")
  "eU" 'elpaca-update-all
  "em" 'elpaca-manager
  "et" 'elpaca-try
  "eu" 'elpaca-update
  "t" '(:ignore t :wk "tools")
  "tp" 'prodigy)
#+end_src
*** [b] buffer
#+begin_src emacs-lisp :lexical no
(defun e:switch-to-messages-buffer ()
  (interactive)
  (switch-to-buffer (messages-buffer)))

(e:key-def
  :prefix (e:key-def-prefix "b")
  :non-normal-prefix (e:key-def-non-normal-prefix "b")
  :prefix-command 'e:buffer-command
  :prefix-map 'e:buffer-command-map
  "" '(:ignore t :wk "buffer")
  "b" 'consult-buffer
  "d" 'kill-buffer
  "m" '(e:switch-to-messages-buffer :wk "Messages buffer")
  "s" 'scratch-buffer
  "w" 'read-only-mode)
#+end_src
*** [e] error
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "e")
  :non-normal-prefix (e:key-def-non-normal-prefix "e")
  :prefix-command 'e:error-command
  :prefix-map 'e:error-command-map
  "" '(:ignore t :wk "error")
  "S" 'flycheck-set-checker-executable
  "Y" 'e:flycheck-copy-error-ids
  "b" 'flycheck-buffer
  "c" 'flycheck-clear
  "d" 'flycheck-disable-checker
  "e" 'consult-flycheck
  "h" 'flycheck-describe-checker
  "l" 'flycheck-list-errors
  "n" 'flycheck-next-error
  "p" 'flycheck-previous-error
  "s" 'flycheck-select-checker
  "v" 'flycheck-verify-setup
  "x" 'flycheck-explain-error-at-point
  "y" 'flycheck-copy-errors-as-kill)
#+end_src
*** [f] file
#+begin_src emacs-lisp :lexical no
(defun e:file/find-user-init-file ()
  (interactive)
  (find-file-existing user-init-file))
(defun e:file/find-early-init-file ()
  (interactive)
  (find-file-existing early-init-file))
(defun e:file/find-config-file ()
  (interactive)
  (find-file-existing (f-expand "readme.org" user-emacs-directory)))
(defun e:make-config ()
  (interactive)
  (let ((default-directory user-emacs-directory))
    (async-shell-command "make")))

(e:key-def
  :prefix (e:key-def-prefix "f")
  :non-normal-prefix (e:key-def-non-normal-prefix "f")
  :prefix-command 'e:file-command
  :prefix-map 'e:file-command-map
  "" '(:ignore t :wk "file")
  "S" 'evil-write-all
  "a" 'find-alternate-file
  "e" '(:ignore t :wk "emacs")
  "eI" '(e:file/find-early-init-file :wk "early-init.el")
  "ed" '(e:file/find-config-file :wk "readme.org")
  "ei" '(e:file/find-user-init-file :wk "init.el")
  "em" '(e:make-config :wk "Make config")
  "f" 'find-file
  "g" 'affe-grep
  "r" 'consult-recent-file
  "s" 'save-buffer
  "z" 'affe-find)
#+end_src
*** [g] git/vc
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "g")
  :non-normal-prefix (e:key-def-non-normal-prefix "g")
  :prefix-command 'e:git-command
  :prefix-map 'e:git-command-map
  "" '(:ignore t :wk "git")
  "L" 'magit-list-repositories
  "S" 'magit-stage-file
  "U" 'magit-unstage-file
  "f" '(:ignore t :wk "file")
  "fc" 'magit-file-checkout
  "fd" 'magit-diff
  "ff" 'magit-find-file
  "fl" 'magit-log-buffer-file
  "fm" 'magit-file-dispatch
  "m" 'magit-dispatch
  "o" 'browse-at-remote
  "s" 'magit-status
  "v" '(:ignore t :wk "vc")
  "vh" 'vc-region-history)
#+end_src
*** [h] help
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "h")
  :non-normal-prefix (e:key-def-non-normal-prefix "h")
  :prefix-command 'e:help-command
  :prefix-map 'e:help-command-map
  "" '(:ignore t :wk "help")
  "d" '(:ignore t :wk "describe")
  "dF" 'consult-faces
  "dK" 'describe-keymap
  "da" 'helm-apropos
  "dd" '(:ignore t :wk "devdocs")
  "ddd" 'devdocs-lookup
  "ddi" 'devdocs-install
  "ddl" 'devdocs-lookup
  "ddp" 'devdocs-peruse
  "ddq" 'devdocs-lookup
  "dds" 'devdocs-search
  "ddu" 'devdocs-update-all
  "df" 'describe-function
  "dK" 'find-function-on-key
  "dk" 'describe-key
  "dv" 'describe-variable
  "h" '(:ignore t :wk "helpful")
  "hc" 'helpful-callable
  "hf" 'helpful-function
  "hh" 'helpful-at-point
  "hi" 'helpful-command
  "hk" 'helpful-key
  "hm" 'helpful-macro
  "hs" 'helpful-symbol
  "hv" 'helpful-variable)
#+end_src
*** [j] jump/join⇔split
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "j")
  :non-normal-prefix (e:key-def-non-normal-prefix "j")
  :prefix-command 'e:jump-command
  :prefix-map 'e:jump-command-map
  "" '(:ignore t :wk "jump")
  "d" 'dired-jump
  "i" 'consult-imenu
  "o" 'consult-outline)
#+end_src
*** [l] layout
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "l")
  :non-normal-prefix (e:key-def-non-normal-prefix "l")
  :prefix-command 'e:layout-command
  :prefix-map 'e:layout-command-map
  "" '(:ignore t :wk "layout")
  "1" '(tab-bar-select-tab-1 :wk "tab 1")
  "2" '(tab-bar-select-tab-2 :wk "tab 2")
  "3" '(tab-bar-select-tab-3 :wk "tab 3")
  "4" '(tab-bar-select-tab-4 :wk "tab 4")
  "5" '(tab-bar-select-tab-5 :wk "tab 5")
  "6" '(tab-bar-select-tab-6 :wk "tab 6")
  "7" '(tab-bar-select-tab-7 :wk "tab 7")
  "8" '(tab-bar-select-tab-8 :wk "tab 8")
  "9" '(tab-bar-select-tab-9 :wk "tab 9")
  "TAB" 'tab-switch-last
  "D" 'tab-close-other
  "c" 'tab-new
  "d" 'tab-close
  "l" 'tab-switch
  "n" 'tab-next
  "p" 'tab-previous
  "r" 'tab-rename)
#+end_src
*** [p] project
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "p")
  :non-normal-prefix (e:key-def-non-normal-prefix "p")
  :prefix-command 'e:project-command
  :prefix-map 'e:project-command-map
  "" '(:ignore t :wk "project")
  "!" 'projectile-run-shell-command-in-root
  "%" 'projectile-replace-regexp
  "&" 'projectile-run-async-shell-command-in-root
  "D" 'projectile-dired
  "F" 'projectile-find-file-dwim
  "G" 'projectile-regenerate-tags
  "I" 'projectile-invalidate-cache
  "P" 'consult-projectile-switch-project
  "R" 'projectile-replace
  "T" 'projectile-test-project
  "a" 'projectile-toggle-between-implementation-and-test
  "b" 'consult-projectile-switch-to-buffer
  "c" 'projectile-compile-project
  "d" 'consult-projectile-find-dir
  "e" 'projectile-edit-dir-locals
  "f" 'consult-projectile-find-file
  "g" 'projectile-find-tag
  "k" 'projectile-kill-buffers
  "p" 'consult-projectile
  "r" 'consult-projectile-recentf
  "v" 'projectile-vc)
#+end_src
*** [q] quit
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (format "SPC %s" "q")
  :non-normal-prefix (e:key-def-non-normal-prefix "q")
  :prefix-command 'e:quit-command
  :prefix-map 'e:quit-command-map
  "" '(:ignore t :wk "quit")
  "q" 'exit
  "r" 'restart-emacs)
#+end_src
*** [s] search/symbol
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "s")
  :non-normal-prefix (e:key-def-non-normal-prefix "s")
  :prefix-command 'e:search-command
  :prefix-map 'e:search-command-map
  "" '(:ignore t :wk "search")
  "D" 'consult-ripgrep-cwd-dwim
  "O" 'symbol-overlay-remove-all
  "S" 'consult-line-dwim
  "d" 'consult-ripgrep-cwd
  "f" 'consult-fd
  "o" 'symbol-overlay-put
  "s" 'consult-line
  "t" 'consult-todo)
#+end_src
*** [t] toggle
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "t")
  :non-normal-prefix (e:key-def-non-normal-prefix "t")
  :prefix-command 'e:toggle-command
  :prefix-map 'e:toggle-command-map
  "" '(:ignore t :wk "toggle")
  "l" 'toggle-truncate-lines
  "t" 'consult-minor-mode-menu)
#+end_src
*** [w] window
#+begin_src emacs-lisp :lexical no
(e:key-def
  :prefix (e:key-def-prefix "w")
  :non-normal-prefix (e:key-def-non-normal-prefix "w")
  :prefix-command 'e:window-command
  :prefix-map 'e:window-command-map
  "" '(:ignore t :wk "window")
  "-" 'split-window-below
  "/" 'split-window-right
  "1" 'delete-other-windows
  "=" 'balance-windows
  "D" 'ace-delete-window
  "H" 'evil-window-move-far-left
  "J" 'evil-window-move-very-bottom
  "K" 'evil-window-move-very-top
  "L" 'evil-window-move-far-right
  "M" 'ace-swap-window
  "U" 'winner-redo
  "W" 'ace-window
  "d" 'delete-window
  "h" 'evil-window-left
  "j" 'evil-window-down
  "k" 'evil-window-up
  "l" 'evil-window-right
  "u" 'winner-undo
  "w" 'other-window)
#+end_src
*** [x] text
#+begin_src emacs-lisp :lexical no
(e:key-def
 :prefix (e:key-def-prefix "x")
 :non-normal-prefix (e:key-def-non-normal-prefix "x")
 :prefix-command 'e:text-command
 :prefix-map 'e:text-command-map
 "" '(:ignore t :wk "text")
 "c" 'count-words-region
 "d" '(:ignore t :wk "delete")
 "d SPC" 'cycle-spacing
 "dl" 'delete-blank-lines
 "dw" 'delete-trailing-whitespace
 "g" '(:ignore t :wk "google/grugru")
 "gg" 'grugru
 "l" '(:ignore t :wk "lines")
 "ls" 'sort-lines)
#+end_src
** global-map
#+begin_src emacs-lisp :lexical no
(general-def global-map
  [remap undo-redo] 'undo-fu-only-redo
  [remap undo] 'undo-fu-only-undo
  [remap yank] 'consult-yank-replace
  "C-*" 'org-support/popup-note
  "C-:" 'org-support/popup-tasks
  "C-;" 'shell-pop
  "C-<" 'evil-jump-backward
  "C->" 'evil-jump-forward
  "C-^" 'ace-window)
#+end_src
** ctl-x-map
#+begin_src emacs-lisp :lexical no
(general-def ctl-x-map
  "C-c" 'execute-extended-command)
#+end_src
* 設定完了
** 完了処理
#+begin_src emacs-lisp :lexical no
(e:variable! e:deffered-config-loaded t)
(e:deffered-config! scratch
  :config
  (scratch-buffer)
  (lisp-interaction-mode))
#+end_src
** パッケージのインストール待ち
#+begin_src emacs-lisp :lexical no
(eval-when-compile (elpaca-wait))
(add-hook 'after-init-hook #'elpaca-wait)
#+end_src
** 優先度高めの設定
#+begin_src emacs-lisp :lexical no
(defvar e:high-priority-config-queue-timer nil)
(defun e:process-high-priority-config-queue ()
  (setq e:high-priority-config-queue-timer
        (run-with-timer
         0.0 0.001
         (lambda ()
           (if e:high-priority-config-queue
               (let ((inhibit-message t))
                 (funcall (pop e:high-priority-config-queue)))
             (cancel-timer e:high-priority-config-queue-timer))))))
(add-hook 'emacs-startup-hook #'e:process-high-priority-config-queue)
#+end_src
** 優先度低めの設定
#+begin_src emacs-lisp :lexical no
(defvar e:low-priority-config-queue-timer nil)
(defun e:process-low-priority-config-queue ()
  (setq e:low-priority-config-queue-timer
        (run-with-timer
         0.2 0.005
         (lambda ()
           (if e:low-priority-config-queue
               (let ((inhibit-message t))
                 (funcall (pop e:low-priority-config-queue)))
             (cancel-timer e:low-priority-config-queue-timer))))))
(add-hook 'emacs-startup-hook #'e:process-low-priority-config-queue)
#+end_src

** 起動時間の計測
#+begin_src emacs-lisp :lexical no
(when init-file-debug
  (eval-when-compile (require 'profiler))
  (profiler-report)
  (profiler-stop))
#+end_src